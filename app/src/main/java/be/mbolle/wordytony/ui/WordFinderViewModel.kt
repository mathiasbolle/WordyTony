package be.mbolle.wordytony.ui

import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import be.mbolle.wordytony.data.words
import be.mbolle.wordytony.model.Character

class WordFinderViewModel: ViewModel() {
    private val width: Int = 5
    private val height: Int = 8

    var terrain: Array<Array<Char>> = Array(width) { Array(height) { ' ' } }
        private set

    val chosenCharacters = emptySet<Character>()
    var correctCharacters = emptySet<Character>()

    var uiState by mutableStateOf(WordFinderState(
        characters = Array(width) { Array(height) { Character(' ')} },
        randomWord = words.random()
    ))
        private set

    init {
        initSearchableWord(width, height)
    }

    fun getRandomWord(): String {
        return ""
    }

    fun chooseIndexInBoard(chosenWord: String, variableIndex: Int): Int {
        var validEndIndexes: Array<Int> = (0..variableIndex).toList().toTypedArray()

        validEndIndexes = validEndIndexes.filter { index ->
            index + (chosenWord.length - 1) > variableIndex
        }.toTypedArray()

        return validEndIndexes.random()
    }

    /**
     * Places the generated word from in a index-based grid.
     * This grid is further generated by
     */
    fun initSearchableWord(width: Int, height: Int) {
        val chosenWord = words.random()
        Log.d("WordFinderViewModel", "The chosen word $chosenWord")

        val directionOfWord = Direction.WIDTH
        Log.d("WordFinderViewModel", directionOfWord.name)

        val widthIndex = width - 1
        val heightIndex = height - 1

        when (directionOfWord) {

            Direction.WIDTH -> {
                // generate a random value between 0 (index) and (width-1) where 0+length of word
                var validEndIndexes: Array<Int> = (0..widthIndex).toList().toTypedArray()

                validEndIndexes = validEndIndexes.filter { index ->
                    index + 1 >= chosenWord.length
                }.toTypedArray()
                Log.d("x", validEndIndexes.toList().toString())
                val validEndIndex = validEndIndexes.random()

                val widthIndexes = validIndexesOfWord(chosenWord, validEndIndex)

                Log.d("x", widthIndexes.toList().toString())
                val constantHeight = (0..heightIndex).random()

                widthIndexes.forEachIndexed { index, element ->
                    terrain[element][constantHeight] = chosenWord[index]
                }

                Log.d("WordfinderViewModel", terrain.toString())

                terrain = fillUpEmptySpots(terrain)
            }

            Direction.WIDTH_HEIGHT -> {

            }


            Direction.HEIGHT -> {

            }

            Direction.INVALID -> {

            }
        }
    }

    private fun validIndexesOfWord(word: String, endIndex: Int): Array<Int> {
        var x = endIndex
        val output: Array<Int> = IntArray(word.length).toTypedArray()

        word.forEachIndexed { index, element ->
            output[index] = x
            x--
        }

        return output.reversedArray()
    }

    fun fillUpEmptySpots(terrain: Array<Array<Char>>): Array<Array<Char>> {
        return terrain.map {
            element -> element.map {
                nextElement -> if (nextElement == ' ') ('A'..'Z').random() else nextElement
            }.toTypedArray()
        }.toTypedArray()
    }

    private fun getDirectionFromWord(word: String, width: Int, height: Int): Direction {
        if (word.length > width && word.length > height) {
            return Direction.INVALID
        }
        if (word.length <= width) {
            if (word.length <= height) {
                return Direction.WIDTH_HEIGHT
            }
            return Direction.WIDTH
        }
        return Direction.HEIGHT
    }
}

/**
 * The possible directions that a word can be placed on the screen.
 */
enum class Direction {
    WIDTH, HEIGHT, WIDTH_HEIGHT, INVALID
}