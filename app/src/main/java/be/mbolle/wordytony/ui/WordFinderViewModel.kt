package be.mbolle.wordytony.ui

import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import be.mbolle.wordytony.data.words
import be.mbolle.wordytony.model.Character

class WordFinderViewModel: ViewModel() {
    private val width: Int = 5
    private val height: Int = 8

    var terrain: Array<Array<Char>> = Array(width) { Array(height) { ' ' } }
        private set

    val chosenCharacters = emptySet<Character>()
    var correctCharacters = emptySet<Character>()

    var uiState by mutableStateOf(WordFinderState(
        characters = Array(width) { Array(height) { Character(' ')} },
        randomWord = words.random()
    ))
        private set

    init {
        initSearchableWord(width, height)
    }


    fun registerKey(wIndex: Int, hIndex: Int) {
        //query the character
        val mutableCharacters = uiState.characters.toMutableList()
        mutableCharacters[wIndex][hIndex] =
            Character(mutableCharacters.get(wIndex).get(hIndex).content, true)



        uiState = uiState.copy(
            characters = mutableCharacters.toTypedArray(),
            randomWord = uiState.randomWord
        )


        //add to chosenCharacter
        //if it is correct to correctCharacters give toast message or smth?

    }


    fun chooseEndIndexInBoard(chosenWord: String, variableIndex: Int): Int {
        var validEndIndexes: Array<Int> = (0..variableIndex).toList().toTypedArray()

        validEndIndexes = validEndIndexes.filter { index ->
            index + 1 >= chosenWord.length
        }.toTypedArray()
        Log.d("x", validEndIndexes.toList().toString())

        return validEndIndexes.random()
    }

    /**
     * Places the generated word from in a index-based grid.
     * This grid is further generated by
     */
    fun initSearchableWord(width: Int, height: Int) {
        val chosenWord = uiState.randomWord
        Log.d("WordFinderViewModel", "The chosen word $chosenWord")

        val directionOfWord = getDirectionFromWord(chosenWord, width, height)
        Log.d("WordFinderViewModel", directionOfWord.name)

        val widthIndex = width - 1
        val heightIndex = height - 1

        when (directionOfWord) {
            Direction.WIDTH_HEIGHT -> {
                val constantHeight = (0..heightIndex).random()
                val constantWidth = (0..widthIndex).random()
                val randomDirection = setOf(Direction.WIDTH, Direction.HEIGHT).random()

                if (randomDirection == Direction.WIDTH) {
                    placeWordInWidth(chosenWord, widthIndex, constantHeight, randomDirection)
                } else {
                    placeWordInHeight(chosenWord, heightIndex, constantWidth, randomDirection)
                }
            }

            Direction.WIDTH -> {
                val constantHeight = (0..heightIndex).random()
                setWordOnGrid(chosenWord, widthIndex, constantHeight, directionOfWord)
            }

            Direction.HEIGHT -> {
                Log.d("x", "heh")
                val constantWidth = (0..widthIndex).random()
                setWordOnGrid(chosenWord, heightIndex, constantWidth, directionOfWord)
            }
            Direction.INVALID -> {
                // TODO handle some error state right here!
            }
        }
        uiState = uiState.copy(
            characters = fillUpEmptySpots(uiState.characters),
            randomWord = uiState.randomWord
        )
        //terrain = fillUpEmptySpots(terrain)
    }

    fun placeWordInWidth(word: String, widthIndex: Int, heightIndex: Int, directionOfWord: Direction) {
        val constantHeight = (0..heightIndex).random()
        setWordOnGrid(word, widthIndex, constantHeight, directionOfWord)
    }

    fun placeWordInHeight(word: String, widthIndex: Int, heightIndex: Int, directionOfWord: Direction) {
        val constantWidth = (0..widthIndex).random()
        setWordOnGrid(word, heightIndex, constantWidth, directionOfWord)
    }

    private fun setWordOnGrid(word: String, variableIndex: Int, constantIndex: Int, direction: Direction) {
        val endIndexOfWord = chooseEndIndexInBoard(word, variableIndex)
        val widthIndexes = indexesOf(word, endIndexOfWord)

        val constantHeight = (0..constantIndex).random()

        if (direction == Direction.WIDTH) {
            widthIndexes.forEachIndexed { index, element ->
                uiState.characters[element][constantHeight] = Character(word[index])
                //terrain[element][constantHeight] = word[index]
            }
        } else {
            widthIndexes.forEachIndexed { index, element ->
                uiState.characters[constantHeight][element] = Character(word[index])
                //terrain[constantHeight][element] = word[index]
            }
        }
    }

    private fun indexesOf(word: String, endIndex: Int): Array<Int> {
        var x = endIndex
        val output: Array<Int> = IntArray(word.length).toTypedArray()

        word.forEachIndexed { index, element ->
            output[index] = x
            x--
        }

        return output.reversedArray()
    }

    fun fillUpEmptySpots(terrain: Array<Array<Character>>): Array<Array<Character>> {
        return terrain.map {
            element -> element.map {
                nextElement -> if (nextElement.content == ' ') Character(('A'..'Z').random()) else nextElement
            }.toTypedArray()
        }.toTypedArray()
    }


    private fun getDirectionFromWord(word: String, width: Int, height: Int): Direction {
        if (word.length > width && word.length > height) {
            return Direction.INVALID
        }
        if (word.length <= width) {
            if (word.length <= height) {
                return Direction.WIDTH_HEIGHT
            }
            return Direction.WIDTH
        }
        return Direction.HEIGHT
    }
}

/**
 * The possible directions that a word can be placed on the screen.
 */
enum class Direction {
    WIDTH, HEIGHT, WIDTH_HEIGHT, INVALID
}