package be.mbolle.wordytony.ui

import android.util.Log
import androidx.lifecycle.ViewModel
import be.mbolle.wordytony.data.words

class WordFinderViewModel(): ViewModel() {


    private val usedWords: Set<String> = mutableSetOf()
    private val width: Int = 5
    private val height = 8
    var terrain: Array<Array<Char>> = Array(width) { Array(height) { ' ' } }
        private set


    init {
        initSearchableWord(width, height)
    }

    /**
     * Places the generated word from in a index-based grid.
     * This grid is further generated by
     */
    fun initSearchableWord(width: Int, height: Int) {
        val chosenWord = words.random()
        Log.d("WordFinderViewModel", "The chosen word $chosenWord")
        //val directionOfWord = getDirectionFromWord(chosenWord, width, height)
        val directionOfWord = Direction.WIDTH
        Log.d("WordFinderViewModel", directionOfWord.name)

        val widthIndex = width - 1
        val heightIndex = height - 1

        when (directionOfWord) {

            Direction.WIDTH -> {
                // generate a random value between 0 (index) and (width-1) where 0+length of word
                var validEndIndexes: Array<Int> = (0..widthIndex).toList().toTypedArray()

                validEndIndexes = validEndIndexes.filter { index ->
                    index + (chosenWord.length - 1) > widthIndex
                }.toTypedArray()

                val validEndIndex = validEndIndexes.random()

                val widthIndexes = validIndexesOfWord(chosenWord, validEndIndex)

                val constantHeight = (0..heightIndex).random()

                widthIndexes.forEachIndexed { index, element ->
                    terrain[element][constantHeight] = chosenWord[index]
                }

                Log.d("WordfinderViewModel", terrain.toString())

                terrain = fillUpEmptySpots(terrain)
            }

            Direction.WIDTH_HEIGHT -> {

            }


            Direction.HEIGHT -> {

            }

            Direction.INVALID -> {

            }
        }
    }

    private fun validIndexesOfWord(word: String, endIndex: Int): Array<Int> {
        var endIndex = endIndex
        val output: Array<Int> = IntArray(word.length).toTypedArray()

        word.forEachIndexed { index, element ->
            output[index] = endIndex
            endIndex--
        }

        return output.reversedArray()
    }

    fun fillUpEmptySpots(terrain: Array<Array<Char>>): Array<Array<Char>> {
        return terrain.map {
            element -> element.map {
                nextElement -> if (nextElement == ' ') ('A'..'Z').random() else nextElement
            }.toTypedArray()
        }.toTypedArray()
    }

    private fun getDirectionFromWord(word: String, width: Int, height: Int): Direction {
        if (word.length > width && word.length > height) {
            return Direction.INVALID
        }
        if (word.length <= width) {
            if (word.length <= height) {
                return Direction.WIDTH_HEIGHT
            }
            return Direction.WIDTH
        }
        return Direction.HEIGHT
    }
}

/**
 * The possible directions that a word can be placed on the screen.
 */
enum class Direction {
    WIDTH, HEIGHT, WIDTH_HEIGHT, INVALID
}